{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Uni{corn|form} Tool Kit","text":"<p> The UTK tool kit aims at providing executables to generate and analyze point sets in unit domains [0,1)^s. It is originally meant to help researchers developing sampling patterns in a numerical integration using Monte Carlo estimators. More precisely, it was developed with the precise question of optimizing image synthesis via Path tracing algorithms.</p> <p>UTK is a C++ library that implements a large variety of samplers and tools to analyze and compare them (discrepancy evaluation, spectral analysis, numerical integration tests\u2026).</p>"},{"location":"#license","title":"License","text":"<p>The core of the library is available under the BSD license. For some samplers, the library is just a wrapper on some codes with specific license (see the samplers page for details).</p>"},{"location":"#clone-and-build","title":"Clone and Build","text":"<p>UTK is hosted on a git repository. To install it, the first step is to clone the repository on your computer. This can be done using the following command line:</p> <pre><code>git clone https://github.com/utk-team/utk.git\n</code></pre> <p>The code can be build on a Linux or a Mac environment. The Windows build is not yet supported. To build it, one can use the following commands, assuming the current working directory is the cloned utk repository.</p> <pre><code>mkdir build\ncd build\ncmake ..\nmake\n</code></pre> <p>See <code>Using UTK/*</code> documentation pages for mor information and building options. </p>"},{"location":"#external-libraries","title":"External libraries","text":"<p>Main external libraries are downloaded automatically by CMake (spdlog, cli11). When the python binding is enabled (cmake flag <code>UTK_PYTHON</code> set to true), pybind11 is fetched.</p> <p>If <code>UTK_USE_FFTW</code> cmake flag is set to true (the default setting) and if the fftw library is available on your system, the Fourier tools will use it.</p> <p>Finally, if <code>UTK_USE_CGAL</code> is set to true, samplers with CGAL as dependency will be built. CGAL and SuiteSparse must be installed on your system.</p>"},{"location":"#authors","title":"Authors","text":"<p>The UTK library was developed mainly by</p> <ul> <li>David Coeurjolly david.coeurjolly@liris.cnrs.fr</li> <li>H\u00e9l\u00e8ne Perrier helene.perrier@liris.cnrs.fr</li> <li>Bastien Doignies bastien.doignies@liris.cnrs.fr</li> </ul> <p>But was also contributed to by</p> <ul> <li>Victor Ostromoukhov victor.ostromoukhov@liris.cnrs.fr</li> <li>Adrien Pilleboue</li> <li>Jean David Genevaux</li> </ul> <p>If you want to refer to UTK in your publications, please use the following bibtex entry:</p> <pre><code>@Misc{UTK,\ntitle = {Uni(corn|form) tool kit},\nnote = {url{https://utk-team.github.io/utk/}}\n}\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>UTK is an open-source, community driven, project. If you want to help us (typos, documentations issues, new samplers, new tools\u2026), feel free to create a Pull-Request on the Github project.</p>"},{"location":"changelog/","title":"CHANGELOG.md","text":""},{"location":"changelog/#200","title":"2.0.0","text":"<ul> <li>2023-Jul: 2.0 released <ul> <li>Code refactoring</li> <li>Dimension templating removed</li> <li>Automatic dependancy handling</li> <li>CMake find_package</li> <li>Python Binding</li> </ul> </li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":"<ul> <li>2022-Mar: Adding the reference for the Kronecker K21-2 sampler</li> <li>2021-Dec: Adding Kronecker K21-2 and R2 sample generators</li> <li>2021-Aug: Adding code and documentation for Diaphony</li> <li>2020-Nov: Cleanup in the Generalized L2 Discrepancy code</li> <li>2020-Jan: Bugfix FFTW_INCLUDES headers</li> <li>2020-Jan: More Jittered samplers</li> <li>2019-Nov: Adding Matt Pharr\u2019s variant of PMJ02 (faster)</li> <li>2019-Sep: Adding Lloyd\u2019s relaxation sampler in 3D (toroidal and non-toroidal) domains using Geogram</li> <li>2019-Aug: Global refactoring of the website</li> <li>2019-Jun: Adding Progressive MultiJittered Samplers (PM,PMJ, PMJ02)</li> </ul>"},{"location":"license/","title":"License","text":"<pre><code>/*\n * Coded by H\u00e9l\u00e8ne Perrier helene.perrier@liris.cnrs.fr\n * and Bastien Doignies bastien.doignies@liris.cnrs.fr \n * and David Coeurjolly David.coeurjolly@liris.cnrs.fr\n *\n * Copyright (c) 2023 CNRS Universit\u00e9 de Lyon\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of the UTK project.\n */\n</code></pre>"},{"location":"metrics/BoundaryStar/","title":"Fast bounds on discrepancy","text":""},{"location":"metrics/BoundaryStar/#description","title":"Description","text":"<p>Code from [Thi01]. This tool approximates upper and lower boundaries on the Linf discrepancy. As those approximations can be computed faster than the true value, it allows to approximate the Linf discrepancy of higher dimensional point sets. Can be used in higher dimensions.</p>"},{"location":"metrics/BoundaryStar/#files","title":"Files","text":"<pre><code>src/metrics/BoundariesStar.cpp  \ninclude/utk/metrics/BoundariesStarDiscrepancy.hpp\n</code></pre>"},{"location":"metrics/BoundaryStar/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>BoundariesStarDiscrepancy calculator\nUsage: ./BoundariesStar [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/BoundariesStarDiscrepancy.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::BoundariesStarDiscrepancy().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\ndmin, dmax = pyutk.BoundariesStarDiscrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/BoundaryStar/#license","title":"License","text":""},{"location":"metrics/CenteredL2/","title":"Centered L2 Discrepancy","text":""},{"location":"metrics/CenteredL2/#description","title":"Description","text":"<p>This tool computes the Centered L2 discrepancy of an input pointset using the following formula  from [Hic98].</p>"},{"location":"metrics/CenteredL2/#files","title":"Files","text":"<pre><code>src/metrics/CenteredL2.cpp  \ninclude/utk/metrics/CenteredL2.hpp\n</code></pre>"},{"location":"metrics/CenteredL2/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>GeneralizedL2 calculator\nUsage: ./build/src/metrics/GL2 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/CenteredL2.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::CenteredL2Discrepancy().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.CenteredL2Discrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/CenteredL2/#license","title":"License","text":"<p>BSD, see <code>L2.hpp</code></p>"},{"location":"metrics/Diaphony/","title":"Diaphony","text":""},{"location":"metrics/Diaphony/#description","title":"Description","text":"<p>Diaphony is a metric of point set uniformity closely related to discrepancy. This tool computes the diaphony in s(N^2) time, with N points in dimension s.</p> <p>from ZINTERHOF, P. 1976. Uber einige Absch~itzungen bei der Approximation von Funktionen mit Gleichverteilungsmethoden. Sitzungsber. Osterr. Akad. Wiss. Math.-Natur. K1. H 185, 121-132.</p>"},{"location":"metrics/Diaphony/#files","title":"Files","text":"<pre><code>src/metrics/Diaphony.cpp  \ninclude/utk/metrics/Diaphony.hpp\n</code></pre>"},{"location":"metrics/Diaphony/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Diaphony calculator\nUsage: ./build/src/metrics/Diaphony [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/Diaphony.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::Diaphony().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.Diaphony().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/Diaphony/#license","title":"License","text":"<p>BSD, see <code>Diaphony.hpp</code></p>"},{"location":"metrics/GeneralizedL2/","title":"Generalized L2 Discrepancy","text":""},{"location":"metrics/GeneralizedL2/#description","title":"Description","text":"<p>This tool computes the Generalized L2 discrepancy of an input pointset using the following formula  from [Hic98].</p>"},{"location":"metrics/GeneralizedL2/#files","title":"Files","text":"<pre><code>src/metrics/GL2.cpp  \ninclude/utk/metrics/GL2.hpp\n</code></pre>"},{"location":"metrics/GeneralizedL2/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>GeneralizedL2 calculator\nUsage: ./build/src/metrics/GL2 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/GL2.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::GeneralizedL2().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.GL2Discrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/GeneralizedL2/#license","title":"License","text":"<p>BSD, see <code>GL2.hpp</code></p>"},{"location":"metrics/IntegrationTest/","title":"Integration Test","text":""},{"location":"metrics/IntegrationTest/#description","title":"Description","text":"<p>Performs integration test on a pointset. The choice of integrand is crucial, and should be carefully choosen. UTK  provides some basic test but one may design its own test. </p> <p>Examples may be found in : - include/utk/metrics/Integrands/Heaviside.hpp, src/metrics/BuildHeavisideDatabase.cpp, src/metrics/HeavisideIntegrationTest.hpp  - include/utk/metrics/Integrands/Gaussians.hpp, src/metrics/BuildGaussiansDatabase.cpp, src/metrics/GaussiansIntegrationTest.hpp</p>"},{"location":"metrics/IntegrationTest/#creating-integrands","title":"Creating Integrands","text":"<p>Integrands must derive from <code>utk::Integrand</code> and must implements the folowing methods : </p> <ul> <li>Constructor: Takes as parameter the dimension. </li> <li>GenerateRandom: The method takes a map of string to int, double or string and a seed. First argument is here to    guide generation (for exemple \u201cscaling\u201d of a function). The second is for reproducibility. </li> <li>ReadFromStream: Reads parameters defining a function. </li> <li>WriteToStream: Writes parameters defining a function. </li> <li>Eval: Evaluate the function at a given point.</li> </ul> <p>Additionnal method may also be derived controlling the computation of ground truth:</p> <ul> <li>hasCloseForm: Defaults return false.</li> <li>getIntegral: Will only be used if <code>hasCloseForm() == true</code>. </li> </ul> <p>When <code>hasCloseForm() == false</code>, the ground truth will be computed using QMC samples (likely from Sobol\u2019 + Owen).</p>"},{"location":"metrics/IntegrationTest/#files","title":"Files","text":"<pre><code>include/utk/metrics/IntegrationTest.hpp\n\ninclude/utk/metrics/Integrands/Heaviside.hpp\nsrc/metrics/BuildHeavisideDatabase.cpp\nsrc/metrics/HeavisideIntegrationTest.hpp \n\ninclude/utk/metrics/Integrands/Gaussians.hpp\nsrc/metrics/BuildGaussiansDatabase.cpp\nsrc/metrics/GaussiansIntegrationTest.hpp\n</code></pre>"},{"location":"metrics/IntegrationTest/#usage-for-gaussians","title":"Usage (For gaussians)","text":"<p>Exe C++ Python </p> <pre><code>Integrand database builder\nUsage: ./BuildGaussianIntegrandDatabase [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-o,--output TEXT REQUIRED   Output file\n  -d,--dimension UINT REQUIRED\n                              Dimension\n  -n,--npts UINT REQUIRED     Number of points for integral computation.\n  -m UINT REQUIRED            Number of integrands to compute\n  -s UINT [0]                 Seed (0 means random)\n--sigmamin FLOAT [0.01]     Min value for variance\n  --sigmamax FLOAT [1]        Max value for variance\n\nGaussian Integration calculator\nUsage: ./GaussianIntegrationTest [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n-f,--file,--integrands TEXT REQUIRED\n                              Integrand File\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/samplers/SamplerSobol.hpp&gt;\n\n#include &lt;utk/metrics/IntegrationTest.hpp&gt;\n#include &lt;utk/metrics/Integrands/GaussianIntegrands.hpp&gt;\n\n\nint main()\n{\nutk::Pointset&lt;double&gt; ptsGT;\nutk::Pointset&lt;double&gt; ptsWN;\n\nutk::SamplerSobol sobol(2);\nsobol.generateSamples(ptsGT, 16384); // For integration \n\nutk::SamplerWhitenoise wn(2);\nwn.generateSamples(ptsWN, 1024);\n\nutk::IntegrationTest test;\n\n// Build database\ntest.BuildDatabase&lt;utk::GaussianIntegrand&gt;(\n\"gaussians.db\", // Output file\n2,              // Dimension \n128,            // Number of integrands  \n0,              // seed   \n{{\"smin\", 0.01}, {\"smax\", 1.0}}, // Parameters (variance min and max)\nptsGT           // Points to compute ground truth\n);\n\n// Perform test\n// Reads the Database\ntest.ReadDatabase&lt;utk::GaussianIntegrand&gt;(\n\"gaussians.db\", // File to read\n2               // Dimension\n);\n\n// Compute the statistics\nauto reports = test.compute(ptsWN);\nostream &lt;&lt; report.min &lt;&lt; \" \" &lt;&lt; report.mean &lt;&lt; \" \" &lt;&lt; report.var &lt;&lt; \" \" &lt;&lt; report.max &lt;&lt; '\\n';\n}\n</code></pre> <pre><code># Not supported\n</code></pre>"},{"location":"metrics/IntegrationTest/#license","title":"License","text":"<p>BSD</p>"},{"location":"metrics/L2/","title":"L2 Discrepancy","text":""},{"location":"metrics/L2/#description","title":"Description","text":"<p>This tool computes the L2 discrepancy of an input pointset using the following formula  from [Hic98].</p>"},{"location":"metrics/L2/#files","title":"Files","text":"<pre><code>src/metrics/L2.cpp  \ninclude/utk/metrics/L2.hpp\n</code></pre>"},{"location":"metrics/L2/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>L2 discrepancy calculator\nUsage: ./build/src/metrics/L2 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/L2.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::L2Discrepancy().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.L2Discrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/L2/#license","title":"License","text":"<p>BSD, see <code>L2.hpp</code></p>"},{"location":"metrics/MinDist/","title":"MinDist","text":""},{"location":"metrics/MinDist/#description","title":"Description","text":"<p>Compute minimum distance between points. </p>"},{"location":"metrics/MinDist/#files","title":"Files","text":"<pre><code>src/metrics/MinDist.cpp  \ninclude/utk/metrics/MinDist.hpp\n</code></pre>"},{"location":"metrics/MinDist/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>MinDist calculator\nUsage: ./build/src/metrics/MinDist [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n--euclidean [0]             Use euclidean distance (default is wrap around)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/MinDist.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::MinDist(true /* Toroidal / euclidean distance */).compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.MinDist(\n  True # Toroidal / Euclidean Distance\n).compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/MinDist/#license","title":"License","text":"<p>BSD, see <code>MinDist.hpp</code></p>"},{"location":"metrics/PCF/","title":"PCF","text":""},{"location":"metrics/PCF/#description","title":"Description","text":"<p>The Pair Correlation Function expresses the distribution of distances between pairs of points in a point set. Intuitively, it expresses the number of samples that are at a distance r from a \u201ctypical\u201d sample. Oztireli devised a simplified estimator for this measure in the particular case of isotropic and stationary point processes. It\u2019s this function that is implemented here.</p> <p>Note : When multiples pointset are given to \u2018compute\u2019, the results are averaged.</p>"},{"location":"metrics/PCF/#files","title":"Files","text":"<pre><code>src/metrics/PCF.cpp  \ninclude/utk/metrics/PCF.hpp\n</code></pre>"},{"location":"metrics/PCF/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>PCF calculator\nUsage: ./build/src/metrics/PCF [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n-t,--toroidal [0]           When set, use toroidal distance\n  -b,--nbbins UINT [200]      Number of bins\n  --rmin FLOAT [0.01]         Minimal radius to consider\n  --rmax FLOAT [0.01]         Maximal radius to consider\n  -s,--smoothin FLOAT [0.001] Smoothing value\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/PCF.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\n\nauto pcf = utk::PCF(\ntrue, // Toroidal \n0.01, // Min radius \n0.15, // Max radius\n200,  // Number of bins \n0.001 // Kernel smoothing\n);\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = pcf.compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\npcf = PCF(\n    True, # Toroidal \n    0.01, # Min radius \n    0.15, # Max radius\n    200,  # Number of bins \n    0.001 # Kernel smoothing\n\n)\npcf = pcf.compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/PCF/#license","title":"License","text":"<p>BSD, see <code>UnanchoredL2Discrepancy.hpp</code></p>"},{"location":"metrics/RadialSpectrum/","title":"Radial SPectrum","text":""},{"location":"metrics/RadialSpectrum/#description","title":"Description","text":"<p>Computes Radial Average of the fourier spectrum.</p> <p>When the <code>UTK_USE_FFTW</code> cmake flag is set to true, the Fourier transform is computed using the fftw library (faster for high resolution spectra).</p> <p>Note : C++ API also supports computing the average from an already computed spectrum. </p> <p>Note : When multiples pointset are given to \u2018compute\u2019, the results are averaged.</p>"},{"location":"metrics/RadialSpectrum/#files","title":"Files","text":"<pre><code>src/metrics/Spectrum.cpp  \ninclude/utk/metrics/PCF.hpp\n</code></pre>"},{"location":"metrics/RadialSpectrum/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>RadialSpectrum calculator\nUsage: ./RadialSpectrum [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n-r,--res UINT [0]           Spectrum resolution (0 means automatic)\n--canceldc [0]              When set, cancel the DC peak\n  -s,--scale FLOAT [0.5]      Scale for distance to origin\n  -b,--bins UINT [0]          Number of bins (0 means automatic)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/RadialSpectrum.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\n\nauto rad = utk::RadialSpectrum(\n75,  // Number of bins\n0.5, // Scale for distances (compress / expands bins size)\n101, // Resolution for underlying fourier spectrum, only odd number. If even will use res - 1\ntrue // Cancel DC\n);\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = rad.compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nrad = pyutk.RadialSpectrum(\n  75,  # Number of bins\n  0.5, # Scale for distances (compress / expands bins size)\n  101, # Resolution for underlying fourier spectrum, only odd number. If even will use res - 1\n  True # Cancel DC\n)\nrad = rad.compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/RadialSpectrum/#license","title":"License","text":"<p>BSD, see <code>Spectrum.hpp</code></p>"},{"location":"metrics/Spectrum/","title":"Spectrum","text":""},{"location":"metrics/Spectrum/#description","title":"Description","text":"<p>Computes the Fourier power spectrum of the input point set (Discrete Fourier Transform). </p> <p>When the <code>UTK_USE_FFTW</code> cmake flag is set to true, the Fourier transform is computed using the fftw library (faster for high resolution spectra).</p> <p>Note : functions and scripts returns a linear C-style array of the computed spectrum.  Note : Only odd resolution are supported (so that the DC is properly identified).  Note : When multiples pointset are given to \u2018compute\u2019, the results are averaged.</p>"},{"location":"metrics/Spectrum/#files","title":"Files","text":"<pre><code>src/metrics/Spectrum.cpp  \ninclude/utk/metrics/PCF.hpp\n</code></pre>"},{"location":"metrics/Spectrum/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Spectrum calculator\nUsage: ./Spectrum [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n-r,--res UINT [0]           Spectrum resolution (0 means automatic)\n--canceldc [0]              When set, cancel the DC peak\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/RadialSpectrum.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\n\nauto spec = utk::Spectrum(\n101, // Resolution, only odd number. If even will use res - 1\ntrue // Cancel DC\n);\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = spec.compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nspec = pyutk.Spectrum(\n  101, # Resolution, only odd number. If even will use res - 1\n  True # Cancel DC\n)\nspec = spec.compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/Spectrum/#license","title":"License","text":"<p>BSD, see <code>Spectrum.hpp</code></p>"},{"location":"metrics/SymmetricL2/","title":"Symmetric L2","text":""},{"location":"metrics/SymmetricL2/#description","title":"Description","text":"<p>This tool computes the Symmetric L2 discrepancy of an input pointset using the following formula  from [Hic98].</p>"},{"location":"metrics/SymmetricL2/#files","title":"Files","text":"<pre><code>src/metrics/SymmetricL2.cpp  \ninclude/utk/metrics/SymmetricL2.hpp\n</code></pre>"},{"location":"metrics/SymmetricL2/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>SymmetricL2 calculator\nUsage: ./build/src/metrics/SymmetricL2 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/SymmetricL2.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::SymmetricL2Discrepancy().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.SymmetricL2Discrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/SymmetricL2/#license","title":"License","text":"<p>BSD, see <code>SymmetricL2.hpp</code></p>"},{"location":"metrics/UnanchoredL2/","title":"UnanchoredL2","text":""},{"location":"metrics/UnanchoredL2/#description","title":"Description","text":"<p>This tool computes the Unanchored L2 discrepancy of an input pointset using the following formula  from [Lem09].</p>"},{"location":"metrics/UnanchoredL2/#files","title":"Files","text":"<pre><code>src/metrics/UnanchoredL2.cpp  \ninclude/utk/metrics/UnanchoredL2.hpp\n</code></pre>"},{"location":"metrics/UnanchoredL2/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>UnanchoredL2Discrepancy calculator\nUsage: ./build/src/metrics/UnanchoredL2 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-i,--input TEXT:FILE REQUIRED\n                              Input file\n  -o,--output TEXT            Output file (empty is stdout)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n#include &lt;utk/metrics/UnanchoredL2Discrepancy.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nauto rslt = utk::UnanchoredL2Discrepancy().compute(pts);\n}\n}\n</code></pre> <pre><code>import pyutk\nimport numpy as np\n\nd = pyutk.UnanchoredL2Discrepancy().compute(np.random.uniform(0, 1, (128, 2)))\n</code></pre>"},{"location":"metrics/UnanchoredL2/#license","title":"License","text":"<p>BSD, see <code>UnanchoredL2Discrepancy.hpp</code></p>"},{"location":"samplers/AAPatterns/","title":"Sampler AA Patterns [Ahm16]","text":""},{"location":"samplers/AAPatterns/#description","title":"Description","text":"<p>The AA Pattern sampler from [Ahm16]. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/AAPatterns/#files","title":"Files","text":"<pre><code>src/samplers/AAPatterns.cpp  \ninclude/utk/samplers/SamplerAAPatterns.hpp\nexternals/AAPatterns/*\n</code></pre>"},{"location":"samplers/AAPatterns/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>AAPatterns sampler\nUsage: ./samplers/AAPatterns [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --vfile TEXT [blue]         Path to vector file, or use one of default [ blue, fpo-like, green, pink, step, ]\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerAAPatterns.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerAAPatterns aa; // Default target is 'blue'\naa.setRandomSeed(/* empty means random, can also pass a number */);\naa.setVectorFile(\"green\" /* Or one of supported types*/)\n\n// Check for no errors\nif (aa.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"aapatterns.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\naa = pyutk.AAPatterns()\naa.setVectorFile(\"green\")\nsamples = aa.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/AAPatterns/#results","title":"Results","text":""},{"location":"samplers/AAPatterns/#license","title":"License","text":"<p>See Licence.md file. Author code from \u2018Abdalla Ahmed\u2019 has no licence but is provided with following header.</p> <pre><code>/* Generate a distribution based on an AA pattern and a loadable displacement map\n * Values which depend on pattern parameters are read from a header file so\n *  that different parameters can be used with this code.\n * We could also load these dynamically, but hard-coding them gives substantial speedup\n * Created by Abdalla Ahmed\n * 2014-11-11\n * Last revision 2015-09-10\n */\n</code></pre>"},{"location":"samplers/ART/","title":"Sampler ART [ANH*17]","text":""},{"location":"samplers/ART/#description","title":"Description","text":"<p>The sampler from [ANH*17] For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/ART/#files","title":"Files","text":"<pre><code>src/samplers/ART.cpp  \ninclude/utk/samplers/SamplerART.hpp\nexternals/ART/*\n</code></pre>"},{"location":"samplers/ART/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>ART sampler\nUsage: ./samplers/ART [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --tfile TEXT                Path to table file. Default (empty) is the one provided by the author.\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerART.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::ART art;\n// Check for no errors\nif (art.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"art.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\naa = pyutk.ART()\nsamples = aa.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/ART/#results","title":"Results","text":""},{"location":"samplers/ART/#license","title":"License","text":"<p>See Licence.md file. Author code from \u2018Abdalla Ahmed\u2019 is provided without license. </p>"},{"location":"samplers/CMJ/","title":"Sampler Correlated Multi Jittered [Ken03]","text":""},{"location":"samplers/CMJ/#description","title":"Description","text":"<p>The Correlated Multi-Jitter sampler from [Kens03]. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/CMJ/#files","title":"Files","text":"<pre><code>src/samplers/CMJ.cpp  \ninclude/utk/samplers/SamplerCMJ.hpp\n</code></pre>"},{"location":"samplers/CMJ/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>CMJ sampler\nUsage: ./samplers/CMJ [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerCMJ.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerCMJ cmj;\ncmj.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (art.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"cmj.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\ncmj = pyutk.CMJ()\nsamples = cmj.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/CMJ/#results","title":"Results","text":""},{"location":"samplers/CMJ/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/DartThrowing/","title":"Sampler Dart Throwing [MF92]","text":""},{"location":"samplers/DartThrowing/#description","title":"Description","text":"<p>A naive (relaxed) dart throwing algorithm. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/DartThrowing/#files","title":"Files","text":"<pre><code>src/samplers/DartThrowing.cpp  \ninclude/utk/samplers/SamplerDartThrowing.hpp\n</code></pre>"},{"location":"samplers/DartThrowing/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Dart Throwing sampler\nUsage: ./samplers/DartThrowing [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --relax [1]                 Enable relaxation\n  --euclidean [0]             Use euclidean distance (default is wrap around)\n--relax_factor FLOAT [0.9]  Amount of relaxation applied after too many unsucessful trials\n  --trials UINT [1000]        Number of trials before relaxation occurs\n  --packing FLOAT [-1]        Set packing density to use. If negative use precomputed values (meaningfull only when D &lt; 9)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerDartThrowing.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerDartThrowing dt(\n2 /* dimension */\ntrue,  /* true = relaxed, false = not relaxed */\nfalse, /* false = euclidean distance, true = toroidal*/\n1000,  /* trials before relaxing distance */ 0.9,   /* Relaxation factor */\n-1     /* Packing distance (-1 = precomputed values) */\n);\ndt.setRandomSeed(/* Or a seed */);\n// Check for no errors\nif (dt.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"dt2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\ndt = pyutk.DartThrowing(\n    2,     # dimension, \n    True,  # true = relaxed, false = not relaxed\n    False, # false = euclidean distance, true = toroidal\n    1000,  # trials before relaxing distance \n    0.9,   # Relaxation factor\n    -1     # Packing distance (-1 = precomputed values)\n\n)\nsamples = dt.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/DartThrowing/#results","title":"Results","text":""},{"location":"samplers/DartThrowing/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/FastPoisson/","title":"Sampler Fast Poisson [Bri07]","text":""},{"location":"samplers/FastPoisson/#description","title":"Description","text":"<p>The Fast Poisson sampler from [DH06]. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/FastPoisson/#files","title":"Files","text":"<pre><code>src/samplers/DartThrowing.cpp  \ninclude/utk/samplers/SamplerFastPoisson.hpp\nexternals/FastPoisson/*\n</code></pre>"},{"location":"samplers/FastPoisson/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>FastPoisson sampler\nUsage: ./samplers/FastPoisson [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --method TEXT [DartThrowing]\nMethod. [DartThrowing, BestCandidate, BoundarySampler, Pure, LinearPure, Penrose, Uniform, ]\n-r,--radius FLOAT [0]       Radius in [0.0005, 0.2]. If outside the range, will attempt to find a radius given N.\n  --throwMult UINT [1]        Multiplier for number of throw (for DartThrowing &amp; BestCandidate methods)\n--throws UINT [1000]        Number of throws ().\n  --maximize                  Enable maximization\n  --tiled                     Enable tiling. Might be ignored for tiled-only methods\n  --relaxCount [0]            Number of relaxation to perform\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerFastPoisson.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerFastPoisson fp(\n\"DartThrowing\", /* method */\n0.01,           /* radius */\n1,              /* Throws multiplier */\n1000,           /* Number of throws */\nfalse,          /* Maximize or not */\ntrue,           /* True for tiling, might be ignored */\n10,             /* Number of relaxation steps */\n);\nfp.setRandomSeed(/* Or a seed */);\n// Check for no errors\nif (fp.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"fastpoisson.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nfp = pyutk.FastPoisson(\n    \"DartThrowing\", # method\n    0.01,           # radius\n    1,              # Throws multiplier\n    1000,           # Number of throws\n    False,          # Maximize or not\n    True,           # True for tiling, might be ignored\n    10,             # Number of relaxation steps\n)\nsamples = fp.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/FastPoisson/#results","title":"Results","text":""},{"location":"samplers/FastPoisson/#license","title":"License","text":"<p>See Licence.md file. Author code from \u2018Daniel Dunbar\u2019 is released into the public domain. </p>"},{"location":"samplers/Fattal/","title":"Sampler Fattal [ANH*17]","text":""},{"location":"samplers/Fattal/#description","title":"Description","text":"<p>The sampler from [FAT*11] For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Fattal/#files","title":"Files","text":"<pre><code>src/samplers/Fattal.cpp  \ninclude/utk/samplers/SamplerFattal.hpp\nexternals/Fattal/*\n</code></pre>"},{"location":"samplers/Fattal/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>ART sampler\nUsage: ./samplers/Fattal [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  -t,--temperature FLOAT [0.5]\nTemperature\n  -l,--level UINT [2]         Levels\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerFattal.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerFattal fattal(0.5 /* temperature */, 2 /* levels */);    // Check for no errors\nif (fattal.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"fattal.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nfattal = pyutk.Fattal(\n  0.5, # temperature\n  2,   # levels\n)\nsamples = fattal.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Fattal/#results","title":"Results","text":""},{"location":"samplers/Fattal/#license","title":"License","text":"<p>See Licence.md file. Author code from \u2018Raanan Fattal\u2019 is provided without license. </p>"},{"location":"samplers/Faure/","title":"Sampler Faure [Fau82]","text":""},{"location":"samplers/Faure/#description","title":"Description","text":"<p>The Faure sequence (2D only). For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Faure/#files","title":"Files","text":"<pre><code>src/samplers/Faure.cpp  \ninclude/utk/samplers/SamplerFaure.hpp\n</code></pre>"},{"location":"samplers/Faure/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Faure sampler\nUsage: samplers/SamplerFaure [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerFaure.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerFaure faure(2 /* dimension */);\n\n// Check for no errors\nif (faure.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"faure2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nfaure = pyutk.Faure(d=2)\nsamples = faure.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Faure/#results","title":"Results","text":""},{"location":"samplers/Faure/#license","title":"License","text":"<p>See Licence.md file. Author code is provided with the following license : </p> <p>GNU LGPL, code from https://people.sc.fsu.edu/~jburkardt/cpp_src/faure/faure.html</p>"},{"location":"samplers/ForcedRandom/","title":"Sampler Forced Random [CTS*17]","text":""},{"location":"samplers/ForcedRandom/#description","title":"Description","text":"<p>A sampler based on dithering matrices from [CTS*17].</p>"},{"location":"samplers/ForcedRandom/#files","title":"Files","text":"<pre><code>src/samplers/ForcedRandom.cpp  \ninclude/utk/samplers/SamplerForcedRandom.hpp\nexternals/Fattal/ForcedRandom\n</code></pre>"},{"location":"samplers/ForcedRandom/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>ForcedRandom sampler\nUsage: ./samplers/ForcedRandom [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --sparsity INT [8]          Sparsity coeff\n  --matrixSize UINT [512]     Matrix Size (512, 1024, 2048. Other will be interpreted as 512)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerForcedRandom.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerForcedRandom fr(8 /* sparsity */, 512 /* matrix size */);    // Check for no errors\nif (fr.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"fr.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nfr = pyutk.SamplerForcedRandom(\n  8  , # Sparsity\n  512, # Matrix size\n)\nsamples = fr.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/ForcedRandom/#results","title":"Results","text":""},{"location":"samplers/ForcedRandom/#license","title":"License","text":"<p>See Licence.md file. Author code from is licenced under \u2018Unlicence\u2019 licence. </p>"},{"location":"samplers/Halton/","title":"Sampler Halton [Hal64]","text":""},{"location":"samplers/Halton/#description","title":"Description","text":"<p>The Halton sequence. Samples are generated from reversing the n-ary representation of their index. Each dimension has a different basis and the low discrepancy is ensured if all basis are distinct and are prime numbers. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Halton/#files","title":"Files","text":"<pre><code>src/samplers/Halton.cpp  \ninclude/utk/samplers/SamplerHalton.hpp\n</code></pre>"},{"location":"samplers/Halton/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Halton sampler\nUsage: ./samplers/Halton [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerHalton.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerHalton halton(2 /* dimension */);\n\n// Default are the first 100 primes numbers\nunsigned int basis[] = {3, 5, 7} // Skip base 2\nhalton.setBasisList(basis, 3);\n\n// Check for no errors\nif (halton.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"halton2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nhalton = pyutk.Halton(d=2)\n# Default is the first 100 primes numbers\nhalton.setBasisList([3, 5, 7]) # Skip base 2\nsamples = halton.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/Halton/#results","title":"Results","text":""},{"location":"samplers/Halton/#license","title":"License","text":"<p>See licence.md file. </p>"},{"location":"samplers/Hammersley/","title":"Sampler Hammersley [Ham60]","text":""},{"location":"samplers/Hammersley/#description","title":"Description","text":"<p>The Hammersley sampler. This sampler is only 2D, with the first coordinate obtained by dividing the index of the sample by the total number of samples, and the second coordinate obtained by reversing the binary representation of the index. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Hammersley/#files","title":"Files","text":"<pre><code>src/samplers/Hammersley.cpp  \ninclude/utk/samplers/SamplerHammersley.hpp\n</code></pre>"},{"location":"samplers/Hammersley/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Hammersley sampler\nUsage: ./samplers/Hammersley [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerHammersley.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerHammersley ham;\n\n// Check for no errors\nif (ham.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"ham.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nhalton = pyutk.Hammersley()\nsamples = halton.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/Hammersley/#results","title":"Results","text":""},{"location":"samplers/Hammersley/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/HexagonalGrid/","title":"Sampler Hexagonal Grid","text":""},{"location":"samplers/HexagonalGrid/#description","title":"Description","text":"<p>An hexagonal grid.  </p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/HexagonalGrid/#files","title":"Files","text":"<pre><code>src/samplers/HexagonalGrid.cpp  \ninclude/utk/samplers/SamplerHexagonalGrid.hpp\n</code></pre>"},{"location":"samplers/HexagonalGrid/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>HexGrid sampler\nUsage: ./samplers/HexagonalGrid [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerHexagonalGrid.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerHexagonalGrid hex;\n\n// Check for no errors\nif (hex.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"hex.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\n# Number of samples must be a square\nhexgrid = pyutk.HexagonalGrid()\nsamples = hexgrid.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/HexagonalGrid/#results","title":"Results","text":""},{"location":"samplers/HexagonalGrid/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Korobov/","title":"Sampler Korobov [Kor59]","text":""},{"location":"samplers/Korobov/#description","title":"Description","text":"<p>Korobov lattices. The generator value should be prime relatively to the number of samples, otherwise the point set will not be projection regular. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Korobov/#files","title":"Files","text":"<pre><code>src/samplers/Korobov.cpp  \ninclude/utk/samplers/SamplerKorobov.hpp\n</code></pre>"},{"location":"samplers/Korobov/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Korobov sampler\nUsage: ./samplers/Korobov [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  -g,--gen UINT [3]           Generator (highly recommended to be prime with N)\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerKorobov.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerKorobov korobov(2 /* dimension */, 7 /* generator */);\n\n// Check for no errors\nif (korobov.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"korobov2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nkorobov = pyutk.Korobov(\n  2, # Dimension\n  7  # Generator value\n)\nsamples = korobov.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/Korobov/#results","title":"Results","text":""},{"location":"samplers/Korobov/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Kronecker/","title":"Sampler Kronecker","text":""},{"location":"samplers/Kronecker/#description","title":"Description","text":"<p>A Kronecker sequence is defined by an additive recurrence for each dimension:</p> <p>S[i] = { S[i-1] + a }</p> <p>Where a is an irrational value and {x} denotes the fractional part of x. Multiple choices are supported by default : </p> <ul> <li>R2, R3, R4: [Robets2018]</li> <li>K21_2, K21_3, K21_4 : [Patel2022]</li> <li>K21b_2, K21b_3, K21b_4 : [Patel2022]</li> </ul>"},{"location":"samplers/Kronecker/#files","title":"Files","text":"<pre><code>src/samplers/Kronecker.cpp  \ninclude/utk/samplers/SamplerKronecker.hpp\nexternals/Kronecker/*\n</code></pre>"},{"location":"samplers/Kronecker/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Faure sampler\nUsage: ./build/src/samplers/Kronecker [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --shifts TEXT               Shifts vectors. Supported [R2, R3, R4, K21_2, K21_3, K21_4, K21b_2, K21b_3, K21b_4, ]\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerKronecker.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerKronecker kron(2 /* dimension */);\nkron.setAlphas(\nutk::SamplerKronecker::ParseAlpha(\"K21_2\", 2 /* dimension */)\n);\n\n// Check for no errors\nif (kron.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"kron2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nkron = pyutk.Kronecker(d=2)\nkron.setAlphas(\"K21_2\")\nsamples = kron.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/Kronecker/#results","title":"Results","text":""},{"location":"samplers/Kronecker/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/LDBN/","title":"Sampler LDBN [APC*16]","text":""},{"location":"samplers/LDBN/#description","title":"Description","text":"<p>The LDBN sampler from [APC*16]. This sampler is only 2D. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p> <p>There are two version : </p> <ol> <li>A version that re-compute permutation</li> <li>A lookup table version (recommended)</li> </ol>"},{"location":"samplers/LDBN/#files","title":"Files","text":"<pre><code>src/samplers/LDBN.cpp  \ninclude/utk/samplers/SamplerLDBN.hpp\n</code></pre> <pre><code>src/samplers/LutLDBN.cpp  \ninclude/utk/samplers/LutLDBN.hpp\nexternals/LutLDBN/*\n</code></pre>"},{"location":"samplers/LDBN/#usage-1","title":"Usage (1)","text":"<p>Exe C++ Python </p> <pre><code>LDBN sampler\nUsage: ./samplers/LDBN [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --tilesize UINT [128]       Tile size. WARNING: Other values than 128 might not be properly supported for random generation.\n  --tileFile TEXT             File containing tiles. If empty a new one will be generated on the fly. Tilesize must be set accordingly.\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerLDBN.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerLDBN ldbn;\nldbn.setPermutFile(\"a file\");\nldbn.setTileSize(128);\nldbn.setRandomSeed(/* empty means random, can also pass a number */);\n\n// Check for no errors\nif (ldbn.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"ldbn.dat\", pts);\n}\n}\n</code></pre> <pre><code># No pyutk version supported\n</code></pre>"},{"location":"samplers/LDBN/#usage-2","title":"Usage (2)","text":"<p>Exe C++ Python </p> <pre><code>LDBN(Lut) sampler\nUsage: ./samplers/LutLDBN [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --target TEXT [BNOT]        Target to use. Available (other will be treaded as BNOT): BNOT, STEP,\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerLutLDBN.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerLutLDBN ldbn;\nldbn.setTarget(\"BNOT\" /* or step */);\n\n// Check for no errors\nif (ldbn.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"ldbn.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nldbn = pyutk.LDBN()\nldbn.setTarget(\"BNOT\")\nsamples = kron.sample(1024)  # This is a numpy array !\n</code></pre>"},{"location":"samplers/LDBN/#results","title":"Results","text":""},{"location":"samplers/LDBN/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/LLoyd/","title":"Sampler Lloyd 3D","text":""},{"location":"samplers/LLoyd/#description","title":"Description","text":"<p>This sampler is a wrapper around the geogram library for an efficient implementation of periodic and non-periodic Delaunay triangulation in 3D. The <code>Lloyd_3dd</code> sampler is a standard implementation of Lloyd\u2019s relaxation algorithm.</p>"},{"location":"samplers/LLoyd/#files","title":"Files","text":"<pre><code>src/samplers/Lloyd.cpp  \ninclude/utk/samplers/Lloyd.hpp\nexternals/Lloyd/*\n</code></pre>"},{"location":"samplers/LLoyd/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Lloyd sampler\nUsage: ./samplers/Lloyd [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --steps [100]               Number of steps to perform\n  --toroidal [0]              When set, use toroidal version.\n&lt;/div&gt;\n\n&lt;div class=\"cpp tabcontent\"&gt;\n\n```  cpp\n#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerLloyd.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerLloyd lloyd(100 /* nbSteps */, true /* True for toroidal */ );\nlloyd.setRandomSeed(/* empty means random, can also pass a number */);\n\n// Check for no errors\n    if (lloyd.generateSamples(pts, 1024 /* Number of points, must be a squared */))\n{\nwrite_text_pointset(\"lloyd.dat\", pts);\n}\n}\n</code></pre> <pre><code># No pyutk version supported\n</code></pre>"},{"location":"samplers/LLoyd/#results","title":"Results","text":""},{"location":"samplers/LLoyd/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/NRooks/","title":"Sampler N-Rooks [Shi91]","text":""},{"location":"samplers/NRooks/#description","title":"Description","text":"<p>The N-Rooks sampler. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/NRooks/#files","title":"Files","text":"<pre><code>src/samplers/NRooks.cpp  \ninclude/utk/samplers/SamplerNRooks.hpp\n</code></pre>"},{"location":"samplers/NRooks/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>NRooks sampler\nUsage: ./samplers/NRooks [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n&lt;/div&gt;\n\n&lt;div class=\"cpp tabcontent\"&gt;\n\n```  cpp\n#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerNiederreiter.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerNRooks nrooks(2 /* dimension */);\nnrooks.setRandomSeed(/* empty means random, can also pass a number */);\n\n// Check for no errors\n    if (nrooks.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"nrooks2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nndr = pyutk.Niederreiter(d=2, basis=2)\nsamples = ndr.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/NRooks/#results","title":"Results","text":""},{"location":"samplers/NRooks/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Niederreiter/","title":"Sampler Niederreiter [Nie88]","text":""},{"location":"samplers/Niederreiter/#description","title":"Description","text":"<p>The Niederreiter sequence.  For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Niederreiter/#files","title":"Files","text":"<pre><code>src/samplers/Niederreiter.cpp  \ninclude/utk/samplers/SamplerNiederreiter.hpp\n</code></pre>"},{"location":"samplers/Niederreiter/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Niederreiter sampler\nUsage: ./samplers/Niederreiter [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  -b,--basis UINT [2]         Sampler basis\n&lt;/div&gt;\n\n&lt;div class=\"cpp tabcontent\"&gt;\n\n```  cpp\n#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerNiederreiter.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerNiederreiter ndr(2 /* dimension */, 2 /* basis */);\n\n// Check for no errors\n    if (ndr.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"ndr2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nndr = pyutk.Niederreiter(d=2, basis=2)\nsamples = ndr.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Niederreiter/#results","title":"Results","text":""},{"location":"samplers/Niederreiter/#license","title":"License","text":"<p>See Licence.md file. Author code is released under GNU LGPL licence. </p> <p>GNU LGPL, code from https://people.sc.fsu.edu/~jburkardt/cpp_src/niederreiter2/niederreiter2.html</p>"},{"location":"samplers/PMJ/","title":"Sampler PMJ [PMJ]","text":""},{"location":"samplers/PMJ/#description","title":"Description","text":"<p>The Progressive Multi-Jittered sampler. This sampler is divided in 3 techniques, each giving better results than the previous one:  </p> <p>Progressive Jittered (PJ): Divides the unit square into 4 equal squares. Randomly throws a point into each subsquare. Then divide those subsquares into subsubsquares. Randomly throws points in them, and so on.  </p> <p>Progressive Multi-Jittered (PMJ): Adds to PJ one property: Using PJ, each sample falls into its own square subdivision. With PMJ, each sample falls into its own square subdivision AND its own strata. When throwing points, uses a best candidate algorithm.  </p> <p>Progressive Multi-Jittered(0,2) (PMJ02): Generalizes the previous techniques. If we subdivide the unit square into equal rectangles, each sample falls into its own rectangle.  </p> <p>C++ Implementation of [PMJ]</p> <p><code>PMJ02_Pharr</code> implements Matt Pharr\u2019s variant from the JCGT article \u201cEfficient Generation of Points that Satisfy Two-Dimensional Elementary Intervals\u201d focusing on fast PMJ02 sampling.</p>"},{"location":"samplers/PMJ/#files","title":"Files","text":"<pre><code>src/samplers/PMJ.cpp  \ninclude/utk/samplers/PMJ.hpp\nexternals/PMJ/*\n</code></pre>"},{"location":"samplers/PMJ/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>PMJ sampler\nUsage: ./build/src/samplers/PMJ [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --method TEXT [PMJ02]       Method to use. Available (other will be treaded as PMJ02): PJ, PMJ, PMJ02, PMJ02_Pharr,\n  -c,--candidates UINT [10]   Number of candidates for PMJ02* methods\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerPMJ.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerPMJ pmj(\"PMJ02\" /* method */, 10 /* Number of candidates */);\npmj.setRandomSeed(/* Or a seed */);\n// Check for no errors\nif (pmj.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"pmj02d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\npmj = pyutk.PMJ(\n    \"PMJ02\", # Method\n    10,      # Candidates for PMJ02* methods\n)\nsamples = pmj.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/PMJ/#results","title":"Results","text":""},{"location":"samplers/PMJ/#license","title":"License","text":"<p>See Licence.md file. Licence may differ by methods. See corresponding author files. </p>"},{"location":"samplers/Penrose/","title":"Sampler Penrose [ODJ04]","text":""},{"location":"samplers/Penrose/#description","title":"Description","text":"<p>The N-Rooks sampler. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Penrose/#files","title":"Files","text":"<pre><code>src/samplers/SamplerPenrose.cpp  \ninclude/utk/samplers/SamplerPenrose.hpp\nexternals/Penrose/*\n</code></pre>"},{"location":"samplers/Penrose/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Penrose sampler\nUsage: ./build/src/samplers/Penrose [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n&lt;/div&gt;\n\n&lt;div class=\"cpp tabcontent\"&gt;\n\n```  cpp\n#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerPenrose.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerPenrose penrose;\n\n// Check for no errors\n    if (penrose.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"penrose.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nndr = pyutk.Niederreiter(d=2, basis=2)\nsamples = ndr.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Penrose/#results","title":"Results","text":""},{"location":"samplers/Penrose/#license","title":"License","text":"<p>See Licence.md file. Author code from \u2018Charles Donohue\u2019 has no licence but is provided with following header.</p> <pre><code>File: quasisampler_prototype.h\n Quasisampler prototype.\n\n This is a toy (non-optimized) implementation of the importance sampling\n technique proposed in the paper:\n \"Fast Hierarchical Importance Sampling with Blue Noise Properties\",\n by Victor Ostromoukhov, Charles Donohue and Pierre-Marc Jodoin,\n to be presented at SIGGRAPH 2004.\n\n Implementation by Charles Donohue,\nBased on Mathematica code by Victor Ostromoukhov.\nUniversite de Montreal\n18.08.04\n</code></pre>"},{"location":"samplers/ProjectiveBlueNoise/","title":"Sampler Dart Throwing [Reinert15]","text":""},{"location":"samplers/ProjectiveBlueNoise/#description","title":"Description","text":"<p>Implementation of Projective Blue-Noise Sampling in N-D.</p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/ProjectiveBlueNoise/#files","title":"Files","text":"<pre><code>src/samplers/ProjectiveBlueNoise.cpp  \ninclude/utk/samplers/SamplerProjectiveBlueNoise.hpp\n</code></pre>"},{"location":"samplers/ProjectiveBlueNoise/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Dart Throwing sampler\nUsage: ./samplers/ProjectiveBlueNoise [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --relax [1]                 Enable relaxation\n  --euclidean [0]             Use euclidean distance (default is wrap around)\n--relax_factor FLOAT [0.9]  Amount of relaxation applied after too many unsucessful trials\n  --trials UINT [1000]        Number of trials before relaxation occurs\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerDartThrowing.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerProjectiveBlueNoise dt(\n2 /* dimension */\ntrue,  /* true = relaxed, false = not relaxed */\nfalse, /* false = euclidean distance, true = toroidal*/\n1000,  /* trials before relaxing distance */ 0.9,   /* Relaxation factor */\n);\ndt.setRandomSeed(/* Or a seed */);\n// Check for no errors\nif (dt.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"dt2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\ndt = pyutk.ProjectiveBlueNoise(\n    2,     # dimension, \n    True,  # true = relaxed, false = not relaxed\n    False, # false = euclidean distance, true = toroidal\n    1000,  # trials before relaxing distance \n    0.9,   # Relaxation factor\n)\nsamples = dt.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/ProjectiveBlueNoise/#results","title":"Results","text":""},{"location":"samplers/ProjectiveBlueNoise/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Rank1/","title":"Sampler Rank 1 [Keller04].","text":""},{"location":"samplers/Rank1/#description","title":"Description","text":"<p>The Rank 1 lattices from [Keller04].  </p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Rank1/#files","title":"Files","text":"<pre><code>src/samplers/R1.cpp  \ninclude/utk/samplers/SamplerR1.hpp\n</code></pre>"},{"location":"samplers/Rank1/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>R1 sampler\nUsage: ./build/src/samplers/Rank1 [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  -e,--exhaustive [0]         Enable exhaustive search\n  -f,--fibonacci [0]          Enable fibonnaci lattice\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerR1.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerR1 r1(false /* exhaustive search */, false /* fibonnaci lattice */);\n// Check for no errors\nif (r1.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"r1.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nr1 = pyutk.R1(\n    False,  # Ehaustive search\n    False, # Fibonnaci lattice\n)\nsamples = r1.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Rank1/#results","title":"Results","text":""},{"location":"samplers/Rank1/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/RegularGrid/","title":"Sampler Regular Grid","text":""},{"location":"samplers/RegularGrid/#description","title":"Description","text":"<p>A regular grid.</p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/RegularGrid/#files","title":"Files","text":"<pre><code>src/samplers/RegularGrid.cpp  \ninclude/utk/samplers/SamplerRegularGrid.hpp\n</code></pre>"},{"location":"samplers/RegularGrid/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>RegularGrid sampler\nUsage: ./build/src/samplers/RegularGrid [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerRegularGrid.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerRegularGrid rg(2 /* dimension */);\n// Check for no errors\nif (rg.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"rg2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nrg = pyutk.RegularGrid(d=2)\nsamples = rg.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/RegularGrid/#results","title":"Results","text":""},{"location":"samplers/RegularGrid/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/SinglePeak/","title":"Sampler Single Peak [HSD13]","text":""},{"location":"samplers/SinglePeak/#description","title":"Description","text":"<p>The sampler from [HSD13] with a single peak profile.  </p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/SinglePeak/#files","title":"Files","text":"<pre><code>src/samplers/SinglePeak.cpp  \ninclude/utk/samplers/SinglePeak.hpp\nexternals/SinglePeak/*\n</code></pre>"},{"location":"samplers/SinglePeak/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>SinglePeak sampler\nUsage: ./build/src/samplers/SinglePeak [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --criticalFreq FLOAT [36.5]\nCritical frequency\n  --smoothing FLOAT [8]       Smoothing\n  --peakPower FLOAT [2]       Peak power\n  --peakSmoothing FLOAT [2]   Peak smoothing\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerSinglePeak.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerSinglePeak step(\n36.5, /* critical frequency */\n8,    /* smoothing */\n2,    /* peak smoothing */\n2,    /* peak power */\n);\nstep.setRandomSeed(args-&gt;seed);\n// Check for no errors\nif (step.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"step.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nsp = pyutk.SinglePeak(\n  36.5, # critical frequency\n  8,    # smoothing\n  2,    # peak smoothing\n  2,    # peak power\n)\nsamples = sp.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/SinglePeak/#results","title":"Results","text":""},{"location":"samplers/SinglePeak/#license","title":"License","text":"<p>See Licence.md file. Author code from has no licence but is provided with following header.</p> <pre><code>//\n// Source code for the paper, edited to fit the utk framework\n//\n// D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with\n// Controlled Aliasing\", ACM Trans. Graph., 2013, in press\n//\n// Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer\n//\n</code></pre>"},{"location":"samplers/Sobol/","title":"Sampler Sobol [JK03] [Owe95]","text":""},{"location":"samplers/Sobol/#description","title":"Description","text":"<p>The Sobol sequence. Samples are generated from a binary product between the binary representation of their index and a matrix, generated from primitive polynomials. By default, uses Juo &amp; Kuo tables [JK03].</p> <p>The sequence is scrambled with Owen permutation [Owe95].</p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Sobol/#files","title":"Files","text":"<pre><code>src/samplers/Sobol.cpp  \ninclude/utk/samplers/SamplerSobol.hpp\n</code></pre>"},{"location":"samplers/Sobol/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Sobol sampler\nUsage: ./samplers/Sobol [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --depth UINT [0]            Owen depth (0: no randomness, 32: recommended).\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerStep.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\n// If needed, can add template to use 64bits integers\nutk::SamplerSobol sobol(2 /* dimension */, 32 /* depth */);\nsobol.setRandomSeed(args-&gt;seed);\n// Check for no errors\nif (sobol.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"sobol2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\n# Only 32 bits integers supported\nsobol = pyutk.Sobol(d=2, depth=32) \nsamples = sobol.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Sobol/#results","title":"Results","text":""},{"location":"samplers/Sobol/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Step/","title":"Sampler Single Peak [HSD13]","text":""},{"location":"samplers/Step/#description","title":"Description","text":"<p>The sampler from [HSD13] with a step profile.  </p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Step/#files","title":"Files","text":"<pre><code>src/samplers/Step.cpp  \ninclude/utk/samplers/SamplerStep.hpp\nexternals/Step/*\n</code></pre>"},{"location":"samplers/Step/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Step sampler\nUsage: ./build/src/samplers/Step [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n  --criticalFreq FLOAT [0.606]\nCritical frequency\n  --smoothing FLOAT [8]       Smoothing\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerStep.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerStep step(\n0.606, /* critical frequency */\n8,    /* smoothing */\n);\nstep.setRandomSeed(args-&gt;seed);\n// Check for no errors\nif (step.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"step.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nsp = pyutk.Step(\n  0.606, # Critical frequency\n  8      # Smoothing\n)\nsamples = sp.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Step/#results","title":"Results","text":""},{"location":"samplers/Step/#license","title":"License","text":"<p>See Licence.md file. Author code from has no licence but is provided with following header.</p> <pre><code>//\n// Source code for the paper, edited to fit the utk framework\n//\n// D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with\n// Controlled Aliasing\", ACM Trans. Graph., 2013, in press\n//\n// Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer\n//\n</code></pre>"},{"location":"samplers/Stratified/","title":"Sampler stratified","text":""},{"location":"samplers/Stratified/#description","title":"Description","text":"<p>The domain is partitioned with a grid of k x k. In each cell of this grid, a random sample is generated.  </p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Stratified/#files","title":"Files","text":"<pre><code>src/samplers/Stratified.cpp  \ninclude/utk/samplers/SamplerStratified.hpp\n</code></pre>"},{"location":"samplers/Stratified/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Stratified sampler\nUsage: ./build/src/samplers/Stratified [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerStratified.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerStratified st(2 /* dimension */);\nst.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (st.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"st2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nst = pyutk.Stratified(d=2)\nsamples = st.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Stratified/#results","title":"Results","text":""},{"location":"samplers/Stratified/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/VanDerCorput/","title":"Sampler Hammersley [VDC35]","text":""},{"location":"samplers/VanDerCorput/#description","title":"Description","text":"<p>Van Der Corput sequence (1D only).</p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/VanDerCorput/#files","title":"Files","text":"<pre><code>src/samplers/VanDerCorput.cpp  \ninclude/utk/samplers/SamplerVanDerCorput.hpp\n</code></pre>"},{"location":"samplers/VanDerCorput/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Van Der Corput sampler\nUsage: ./build/src/samplers/VanDerCorput [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerVanDerCorput.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\nutk::SamplerVanDerCorput vdc;\n\n// Check for no errors\nif (vdc.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"vdc.dat\", pts);\n}\n}\n</code></pre> <pre><code># No python binding\n</code></pre>"},{"location":"samplers/VanDerCorput/#results","title":"Results","text":""},{"location":"samplers/VanDerCorput/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"samplers/Whitenoise/","title":"Sampler Whitenoise","text":""},{"location":"samplers/Whitenoise/#description","title":"Description","text":"<p>A pure random sampler</p> <p>For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html.</p>"},{"location":"samplers/Whitenoise/#files","title":"Files","text":"<pre><code>src/samplers/Whitenoise.cpp  \ninclude/utk/samplers/SamplerWhitenoise.hpp\n</code></pre>"},{"location":"samplers/Whitenoise/#usage","title":"Usage","text":"<p>Exe C++ Python </p> <pre><code>Whitenoise sampler\nUsage: ./build/src/samplers/Whitenoise [OPTIONS]\n\nOptions:\n  -h,--help                   Print this help message and exit\n-n UINT REQUIRED            Number of points\n  -d UINT REQUIRED            Dimensions\n  -s,--seed UINT              Seed (unspecified means 'random')\n-m UINT [1]                 Number of pointsets\n  -o,--out TEXT [out.dat]     Output file\n</code></pre> <pre><code>#include &lt;utk/utils/PointsetIO.hpp&gt;\n#include &lt;utk/utils/Pointset.hpp&gt;\n#include &lt;utk/samplers/SamplerWhitenoise.hpp&gt;\n\nint main()\n{\nutk::Pointset&lt;double&gt; pts;\n\nutk::SamplerWhitenoise wn(2 /* dimension */);\nwn.setRandomSeed(/* empty means random, can also pass a number */);\n// Check for no errors\nif (wn.generateSamples(pts, 1024 /* Number of points */))\n{\nwrite_text_pointset(\"wn2d.dat\", pts);\n}\n}\n</code></pre> <pre><code>import pyutk\n\nst = pyutk.Whitenoise(d=2)\nsamples = st.sample(1024) # This is a numpy array !\n</code></pre>"},{"location":"samplers/Whitenoise/#results","title":"Results","text":""},{"location":"samplers/Whitenoise/#license","title":"License","text":"<p>See Licence.md file.</p>"},{"location":"usingutk/CppUtk/","title":"Using UTK C++ library","text":""},{"location":"usingutk/CppUtk/#linking-and-building","title":"Linking and Building","text":"<p>Most of UTK is header only. Hence, setting include path to <code>include/</code> is sufficient. However, some code provided by authors are not header only and should be compiled along your project. </p> <p>If building with CMake, you may use the following lines to get all files required: </p> <pre><code>find_package(UTK)\n# Depending on install location, the following line may be better\n# find_package(UTK PATHS PATH_TO_UTK)\ntarget_link_libraries(YOUR_TARGET UTK_LIBRARY)\n</code></pre> <p>See the documentation and <code>examples/</code> folder for more information. </p>"},{"location":"usingutk/CppUtk/#using-utk-library-with-externals-point-formats","title":"Using UTK Library with externals Point formats","text":"<p>Points and pointsets have many different formats. UTK uses it\u2019s own, but have been designed to be integrated with many other. Internally, the <code>utk::Poinset</code> is a <code>std::shared_ptr</code>.  The class can be constructed in the following ways : </p> <ul> <li><code>utk::Poinset&lt;Type&gt;(uint n, uint d)</code> : Construct a pointset. The memory will be owned by the object. Copies will share the same memory.</li> <li><code>utk::Poinset&lt;Type&gt;::View(T* data, uint n, uint d)</code> : Creates a wrapper around existing memory. The memory will not be deleted automatically, it is to the user to delete it properly. </li> <li><code>utk::Poinset&lt;Type&gt;::Copy(const T* data, uint n, uint d)</code> : Copies the data. The memory will be owned by the returning object. </li> </ul> <p>Only C-style linear buffers are supported.</p> <p>Important note : Points might be stored in particular structures such as <code>struct Point{ float x, y; };</code> and arrays are built upon such as : <code>std::vector&lt;Point&gt;</code>. While technically undefined behavior (but so many codes depends on it, so it may be considered safe), it is possible to obtain an <code>utk::Pointset&lt;float&gt;</code> with the line <code>utk::Pointset&lt;float&gt;::View(static_cast&lt;float*&gt;(vector.data()), N, D)</code>; but be sure that your data are properly packed and aligned. In particular, make sure that there is no other attributes. For instance : <code>struct Point{ float* point; unsigned int N};</code> and <code>struct { std::vector&lt;float&gt; point; };</code> are not valid and copies will be necessary !</p>"},{"location":"usingutk/CppUtk/#miscellaneous-notes","title":"Miscellaneous notes :","text":"<p>How to control parallelism ?: UTK parallelism is handled with the OpenMP library. Most sampler use only a single thread (/!\\ that does not mean they are thread-safe !!!) but metrics are multi-threaded. There are two main ways to control the number of threads : using the openmp library directly in the code <code>omp_set_num_threads</code> or setting the <code>OMP_NUM_THREADS</code> environment variable. By defaults, all available threads are used. </p> <p>How to control logging ?: The library might be built without support for logging at all (with the <code>UTK_LOG</code> CMake option). This is discouraged though. The logger can be partially interacted with, using the following maccros : <code>UTK_LOG_DISABLE()</code>,  <code>UTK_LOG_ENABLE()</code>, <code>UTK_LOG_CONSOLE()</code> (which set log destination to standard output) and <code>UTK_LOG_FILE(filepath)</code> to log directly into a file. </p> <p>Why is each Sampler / Metric a separate class without any base class ? : Short answer : so that code can be extracted more easily. While UTK is a library in itself, it may serve as a sampler code repository. Technically, it is possible to have maccros that enables class dependancy on a common class and while it might be added latter, it is believed that it would add too much complexity for now\u2026</p> <p>How to make a function that takes a sampler as parameter?: Templates ! To run the same function on multiple templates, consider variadic templates and parameter pack expansion (see examples !). While not having a common base class, every sampler have the same generation method !</p>"},{"location":"usingutk/ExeUtk/","title":"Using UTK Executables","text":""},{"location":"usingutk/ExeUtk/#linking-and-building","title":"Linking and Building","text":"<p>To build executable, the following commands are necessary : </p> <pre><code>mkdir build\ncd build\n# Install to specified location, every executable will be located in the \n# YOUR_INSTALL_DIR/bin folder. \ncmake -DCMAKE_INSTALL_PREFIX=. .. \nmake install -j 8 # Or whatever number of threads you want\n</code></pre> <p>Executable will be located in <code>src/samplers</code> and <code>src/metrics folders</code> and, if  <code>make install</code> is run, to the specified directory (without distinction). </p>"},{"location":"usingutk/ExeUtk/#miscellaneous-notes","title":"Miscellaneous notes","text":"<ul> <li> <p>All samplers have common parameters <code>-n</code> for number of points, <code>-d</code> for dimension,  <code>-m</code> for numbers of point sets to generate and <code>-s</code> for seeds. Note that some option  might be ignored for samples that have fixed dimension (2D only) or are deterministic (Sobol\u2019 without scrambling). </p> </li> <li> <p>All metrics have common parameters <code>-i</code> for the input file or <code>-o</code> for output. The  behaviour when multiples point sets are given is the same file might differ : <code>Spectrum</code>  will return an average of all point sets but <code>Discrepancy</code> a list of values for each one. </p> </li> </ul>"},{"location":"usingutk/PyUtk/","title":"Using PyUTK library","text":""},{"location":"usingutk/PyUtk/#building","title":"Building","text":"<p>A conda (or venv) environnment is recommended. There is no requirements for the pyutk library to be built. But to be used, numpy must be available.</p> <p>If using a conda environnment, make sure the proper compiler is detected. It is  recommanded to install GCC via <code>conda install -c conda-force gxx</code>. If the wrong compiler, setting CC and CXX environment variables might help. </p> <p>To build the library run the command <code>pip install -v -e .</code> (dot is part of command) in  the root directory. Everything will be built and linked with your current python interpreter.  A simple test command would be <code>python -c \"import pyutk; print(help(pyutk))\"</code> which shows all samplers and functions availables. </p> <p>Most usage of library is given in the documentation with the python code snippets. A more  elaborate example may be find in the <code>examples/</code> directory. </p>"},{"location":"usingutk/PyUtk/#miscellaneous-notes","title":"Miscellaneous Notes","text":"<ul> <li> <p>Samplers are not thread safes !</p> </li> <li> <p>Metrics uses parallel code. Number of thread might be controlled by setting <code>OMP_NUM_THREADS</code>  this can be done by setting <code>os.environ['OMP_NUM_THREADS']</code></p> </li> <li> <p>Documentation is not exhaustive. Use <code>help(pyutk)</code> to have access to available functions </p> </li> <li> <p>Logs can be enabled and disabled with the functions <code>pyutk.disableLogs()</code>, <code>pyutk.enableLogs()</code>,  <code>pyutk.setLogConsole()</code> (which set log destination to standard output) and <code>pyutk.setLogFile(filepath)</code>  (which set log destination to specified file). </p> </li> <li> <p>The binding is done with the awesome <code>pybind11</code> library. There is no code directly written in python within the library, hence performance are almost the same.  </p> </li> <li> <p>The binding is built to be interoperable with the wonderfull <code>numpy</code> library. Hence there  is no intermediate data representation (such as UTKPointset or equivalent). To be more precised, the library returns numpy array, but accepts any object supporting python buffer protocol API.  </p> </li> <li> <p>The interface is a slighly modified version of CppUTK to be more pythonic. While CppUTK  uses returns code to indicate error, PyUTK returns array and throws exception when something is wrong. </p> </li> <li> <p>Why is my favorite sampler missing in the binding ? : We might have forgot it\u2026 Request the addition :) ! </p> </li> </ul>"}]}